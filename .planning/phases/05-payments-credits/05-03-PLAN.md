---
phase: 05-payments-credits
plan: 03
type: execute
---

<objective>
Implement credit deduction when calls complete.

Purpose: Charge users for voice agent usage based on call duration.
Output: Credit deduction logic in Vapi webhook, call records show creditsUsed, transaction logging.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-payments-credits/05-RESEARCH.md
@.planning/phases/05-payments-credits/05-CONTEXT.md
@.planning/phases/05-payments-credits/05-01-SUMMARY.md
@.planning/phases/05-payments-credits/05-02-SUMMARY.md

**Existing code:**
@src/app/api/webhooks/vapi/route.ts
@src/lib/calls.ts

**Pricing model:**
- $0.15 per minute = 15 cents per minute
- Round up to nearest minute (ceil)
- Example: 4 min 32 sec = 5 minutes = 75 cents

**Grace period logic:**
- If user balance goes below 0, track overage in graceCreditsUsed
- Don't block calls - soft warning only (no hard cutoff per CONTEXT.md)
- Settlement happens on next purchase (already handled in 05-01 webhook)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create credit deduction utility function</name>
  <files>src/lib/credits.ts</files>
  <action>
Create src/lib/credits.ts with credit utilities:

1. Define pricing constants:
   ```typescript
   export const CENTS_PER_MINUTE = 15; // $0.15/minute
   ```

2. Create calculateCallCost function:
   ```typescript
   export function calculateCallCost(durationSeconds: number): number {
     // Round up to nearest minute
     const minutes = Math.ceil(durationSeconds / 60);
     return minutes * CENTS_PER_MINUTE;
   }
   ```

3. Create deductCreditsForCall function:
   ```typescript
   export async function deductCreditsForCall(
     userId: string,
     callId: string,
     durationSeconds: number
   ): Promise<void> {
     const creditsUsed = calculateCallCost(durationSeconds);

     await prisma.$transaction(async (tx) => {
       const user = await tx.user.findUnique({
         where: { id: userId },
         select: { creditBalance: true, graceCreditsUsed: true }
       });

       if (!user) throw new Error('User not found');

       let newBalance = user.creditBalance - creditsUsed;
       let newGraceUsed = user.graceCreditsUsed;

       // Grace period: if balance goes negative, track as grace usage
       if (newBalance < 0) {
         newGraceUsed += Math.abs(newBalance);
         newBalance = 0;
       }

       // Update user balance
       await tx.user.update({
         where: { id: userId },
         data: {
           creditBalance: newBalance,
           graceCreditsUsed: newGraceUsed
         }
       });

       // Record transaction
       await tx.creditTransaction.create({
         data: {
           userId,
           type: newGraceUsed > user.graceCreditsUsed ? 'GRACE_USAGE' : 'CALL_USAGE',
           amount: -creditsUsed,
           balanceAfter: newBalance,
           callId,
           description: `Call: ${Math.ceil(durationSeconds / 60)} min`
         }
       });

       // Update call record with cost
       await tx.call.update({
         where: { id: callId },
         data: { creditsUsed }
       });
     });
   }
   ```

4. Add formatting helpers (move from credits page if created there):
   ```typescript
   export function formatBalance(cents: number): string {
     const dollars = (cents / 100).toFixed(2);
     const minutes = Math.floor(cents / CENTS_PER_MINUTE);
     return `$${dollars} (~${minutes} min)`;
   }

   export function formatCallCost(durationSeconds: number, creditsCents: number): string {
     const minutes = Math.floor(durationSeconds / 60);
     const seconds = durationSeconds % 60;
     const cost = (creditsCents / 100).toFixed(2);
     return `${minutes} min ${seconds} sec - $${cost}`;
   }
   ```

WHY: Atomic transaction ensures balance, grace tracking, and transaction log are always consistent.
  </action>
  <verify>
- npm run build passes
- src/lib/credits.ts exports all functions
  </verify>
  <done>Credit deduction utility with atomic transaction and grace period handling</done>
</task>

<task type="auto">
  <name>Task 2: Integrate credit deduction into Vapi webhook</name>
  <files>src/app/api/webhooks/vapi/route.ts, src/lib/calls.ts</files>
  <action>
Update handleEndOfCallReport in the Vapi webhook:

1. Import deductCreditsForCall from @/lib/credits

2. After updating call record in handleEndOfCallReport, add credit deduction:
   ```typescript
   // Deduct credits for completed calls with duration
   if (finalStatus === CallStatus.COMPLETED && durationSeconds && durationSeconds > 0) {
     try {
       // Get the call record we just upserted
       const callRecord = await prisma.call.findUnique({
         where: { vapiCallId: call.id }
       });

       if (callRecord) {
         await deductCreditsForCall(
           agent.userId,
           callRecord.id,
           durationSeconds
         );
         console.log(`Deducted credits for call ${call.id}: ${durationSeconds}s`);
       }
     } catch (error) {
       console.error('Error deducting credits:', error);
       // Don't throw - credit deduction failure shouldn't break webhook
     }
   }
   ```

3. Update upsertCallFromWebhook in calls.ts:
   - Remove the comment "Phase 5 will handle credit calculation"
   - Keep creditsUsed: 0 on initial create (deduction happens separately after call ends)

CRITICAL: Only deduct for COMPLETED calls with positive duration. Don't deduct for FAILED or NO_ANSWER.
  </action>
  <verify>
- npm run build passes
- Webhook handler imports and calls deductCreditsForCall
  </verify>
  <done>Vapi webhook deducts credits on call completion</done>
</task>

<task type="auto">
  <name>Task 3: Display call costs in call history</name>
  <files>src/components/dashboard/call-row.tsx</files>
  <action>
Update CallRow component to show call cost:

1. Import formatCallCost from @/lib/credits (or implement inline if simpler)

2. Update the component to display:
   - Duration + cost format: "4 min 32 sec - $0.75"
   - If creditsUsed is 0, show just duration (for calls before billing was enabled)

3. The call-row.tsx already displays durationSeconds - add the cost display next to it:
   ```tsx
   {call.durationSeconds !== null && call.durationSeconds > 0 && (
     <span className="text-sm text-gray-500">
       {call.creditsUsed > 0
         ? formatCallCost(call.durationSeconds, call.creditsUsed)
         : formatDuration(call.durationSeconds)}
     </span>
   )}
   ```

Per CONTEXT.md requirement: "4 min 32 sec - $0.85" format for transparency.
  </action>
  <verify>
- npm run build passes
- Call history shows duration with cost for calls that have creditsUsed
  </verify>
  <done>Call history displays duration and cost per CONTEXT.md format</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Credit deduction utility in src/lib/credits.ts
- [ ] Vapi webhook deducts credits on COMPLETED calls
- [ ] Call record updated with creditsUsed
- [ ] CreditTransaction created for each call
- [ ] Grace period triggers when balance would go negative
- [ ] Call history displays "X min Y sec - $Z.ZZ" format
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Credits deducted correctly when calls complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-payments-credits/05-03-SUMMARY.md`
</output>
